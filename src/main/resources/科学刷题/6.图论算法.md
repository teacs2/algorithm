分享丨【算法题单】图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）

## 一、基础遍历

### §1.1 DFS 基础

找连通块、判断是否有环（如 207 题）等。部分题目**做法不止一种**。

模板（计算每个连通块的大小）：

```java
class Solution {
    public List<Integer> solve(int n, int[][] edges) {
        // 节点编号从 0 到 n-1
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, _ -> new ArrayList<>());
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            g[x].add(y);
            g[y].add(x); // 无向图
        }

        // 计算每个连通块的大小
        List<Integer> ans = new ArrayList<>();
        boolean[] vis = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!vis[i]) { // i 没有访问过
                int size = dfs(i, vis, g);
                ans.add(size);
            }
        }
        return ans;
    }

    private int dfs(int x, boolean[] vis, List<Integer>[] g) {
        vis[x] = true; // 避免重复访问节点
        int size = 1;
        for (int y : g[x]) {
            if (!vis[y]) {
                size += dfs(y, vis, g);
            }
        }
        return size;
    }
}
```

- [547\. 省份数量](https://leetcode.cn/problems/number-of-provinces/)
- [1971\. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)
- [797\. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/) 1383
- [841\. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/) 1412
- [2316\. 统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/) 1604
- [1319\. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/) 1633
- [2492\. 两个城市间路径的最小分数](https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/) 1680
- [3310\. 移除可疑的方法](https://leetcode.cn/problems/remove-methods-from-project/) 1711
- [2685\. 统计完全连通分量的数量](https://leetcode.cn/problems/count-the-number-of-complete-components/) 1769
- [2192\. 有向无环图中一个节点的所有祖先](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) 1788
- [3387\. 两天自由外汇交易后的最大货币数](https://leetcode.cn/problems/maximize-amount-after-two-days-of-conversions/) 1788
- [924\. 尽量减少恶意软件的传播](https://leetcode.cn/problems/minimize-malware-spread/) 1869
- [2101\. 引爆最多的炸弹](https://leetcode.cn/problems/detonate-the-maximum-bombs/) 1880
- [721\. 账户合并](https://leetcode.cn/problems/accounts-merge/)
- [207\. 课程表](https://leetcode.cn/problems/course-schedule/) 三色标记法判环
- [802\. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/) 1962
- [928\. 尽量减少恶意软件的传播 II](https://leetcode.cn/problems/minimize-malware-spread-ii/) 1985
- [2092\. 找出知晓秘密的所有专家](https://leetcode.cn/problems/find-all-people-with-secret/) 2004
- [3108\. 带权图里旅途的最小代价](https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/) 2109
- [261\. 以图判树](https://leetcode.cn/problems/graph-valid-tree/)（会员题）
- [323\. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)（会员题）

**思维扩展**：

- [1298\. 你能从盒子里获得的最大糖果数](https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/) 1825

### §1.2 BFS 基础

求最短路等。要求边权都是 （或者说都是同一个正数）。

模板（单源最短路）：

```java
class Solution {
    // 计算从 start 到各个节点的最短路长度
    // 如果节点不可达，则最短路长度为 -1
    // 节点编号从 0 到 n-1，边权均为 1
    public int[] bfs(int n, int[][] edges, int start) {
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, _ -> new ArrayList<>());
        for (int[] e : edges) {
            int x = e[0], y = e[1];
            g[x].add(y);
            g[y].add(x); // 无向图
        }

        int[] dis = new int[n];
        Arrays.fill(dis, -1); // -1 表示尚未访问到
        Queue<Integer> q = new ArrayDeque<>();
        dis[start] = 0;
        q.offer(start);
        while (!q.isEmpty()) {
            int x = q.poll();
            for (int y : g[x]) {
                if (dis[y] < 0) {
                    dis[y] = dis[x] + 1;
                    q.offer(y);
                }
            }
        }
        return dis;
    }
}
```

- [3243\. 新增道路查询后的最短距离 I](https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/) 1568
- [1311\. 获取你好友已观看的视频](https://leetcode.cn/problems/get-watched-videos-by-your-friends/) 1653
- [1129\. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/) 1780
- [2039\. 网络空闲的时刻](https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/) 1865
- [2608\. 图中的最短环](https://leetcode.cn/problems/shortest-cycle-in-a-graph/) 1904
- [815\. 公交路线](https://leetcode.cn/problems/bus-routes/) 1964

注：关于**网格图**的 DFS 和 BFS，请看 [网格图题单](https://leetcode.cn/circle/discuss/YiXPXW/)。

## 二、拓扑排序

![图论题单 图论算法 图论题目 LeetCode 力扣图论 灵茶山艾府](assets/1738131168-tWFNGZ-006-toposort.png)

把拓扑排序想象成一个黑盒，给它一堆杂乱的先修课约束，它会给你一个井井有条的课程学习安排。

这一种在图上的「排序」，可以把杂乱的点排成一排。前提条件是图中无环，从而保证每条边都是从排在前面的点，指向排在后面的点。即对于任意有向边 ， 一定在 之前。

### §2.1 拓扑排序

模板：

```java
class Solution {
    // 返回有向无环图（DAG）的其中一个拓扑序
    // 如果图中有环，返回空列表
    // 节点编号从 0 到 n-1
    public List<Integer> topologicalSort(int n, int[][] edges) {
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, _ -> new ArrayList<>());
        int[] inDeg = new int[n];
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            g[x].add(y);
            inDeg[y]++; // 统计 y 的先修课数量
        }

        Queue<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            if (inDeg[i] == 0) { // 没有先修课，可以直接上
                q.offer(i); // 加入学习队列
            }
        }

        List<Integer> topoOrder = new ArrayList<>();
        while (!q.isEmpty()) {
            int x = q.poll();
            topoOrder.add(x);
            for (int y : g[x]) {
                inDeg[y]--; // 修完 x 后，y 的先修课数量减一
                if (inDeg[y] == 0) { // y 的先修课全部上完
                    q.offer(y); // 加入学习队列
                }
            }
        }

        if (topoOrder.size() < n) { // 图中有环
            return List.of();
        }
        return topoOrder;
    }
}
```

学习拓扑排序前，请先完成 [1557\. 可以到达所有点的最少点数目](https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/)，有助于理解拓扑排序。

- [210\. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)
- [2115\. 从给定原材料中找到所有可以做出的菜](https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/) 1679
- [2392\. 给定条件下构造矩阵](https://leetcode.cn/problems/build-a-matrix-with-conditions/) 1961
- [802\. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/) 1962
- [1591\. 奇怪的打印机 II](https://leetcode.cn/problems/strange-printer-ii/) 2291
- [1203\. 项目管理](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/) 2419
- [2603\. 收集树中金币](https://leetcode.cn/problems/collect-coins-in-a-tree/) 2712
- [LCR 114. 火星词典](https://leetcode.cn/problems/Jf1JuT/)
- [444\. 序列重建](https://leetcode.cn/problems/sequence-reconstruction/)（会员题）拓扑序是否唯一
- [3481\. 应用替换](https://leetcode.cn/problems/apply-substitutions/)（会员题）也可以记忆化搜索
- [269\. 火星词典](https://leetcode.cn/problems/alien-dictionary/)（会员题）
- [1059\. 从始点到终点的所有路径](https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/)（会员题）

**思维扩展**：

- [310\. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

### §2.2 在拓扑序上 DP

一般是刷表法。

- [851\. 喧闹和富有](https://leetcode.cn/problems/loud-and-rich/) 1783
- [2050\. 并行课程 III](https://leetcode.cn/problems/parallel-courses-iii/) 2084
- [3620\. 恢复网络路径](https://leetcode.cn/problems/network-recovery-pathways/)
- [1857\. 有向图中最大颜色值](https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/) 2313
- [1136\. 并行课程](https://leetcode.cn/problems/parallel-courses/)（会员题）

### §2.3 基环树

[基环树介绍](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/)

- [2359\. 找到离给定两个节点最近的节点](https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/) 1715
- [2360\. 图中的最长环](https://leetcode.cn/problems/longest-cycle-in-a-graph/) 1897
- [684\. 冗余连接](https://leetcode.cn/problems/redundant-connection/) 做法不止一种
- [685\. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)
- [2876\. 有向图访问计数](https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/) 2210
- [2127\. 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/) 2449
- [2836\. 在传球游戏中最大化函数值](https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game) 2769 做法不止一种
- [LCP 21. 追逐游戏](https://leetcode.cn/problems/Za25hA/)
- [2204\. 无向图中到环的距离](https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/)（会员题）

## 三、最短路

### §3.1 单源最短路：Dijkstra 算法

[Dijkstra 算法介绍](https://leetcode.cn/problems/network-delay-time/solution/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/)

模板：

```java
class Solution {
    // 返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = Integer.MAX_VALUE
    // 要求：没有负数边权
    // 时间复杂度 O(n + mlogm)，注意堆中有 O(m) 个元素
    private int[] shortestPathDijkstra(int n, int[][] edges, int start) {
        // 注：如果节点编号从 1 开始（而不是从 0 开始），可以把 n 加一
        List<int[]>[] g = new ArrayList[n]; // 邻接表
        Arrays.setAll(g, _ -> new ArrayList<>());
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int wt = e[2];
            g[x].add(new int[]{y, wt});
            // g[y].add(new int[]{x, wt}); // 无向图加上这行
        }

        int[] dis = new int[n]; // **如果数据范围大，改成 long[]**
        Arrays.fill(dis, Integer.MAX_VALUE);
        // 堆中保存 (起点到节点 x 的最短路长度，节点 x)
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        dis[start] = 0; // 起点到自己的距离是 0
        pq.offer(new int[]{0, start});

        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int disX = p[0];
            int x = p[1];
            if (disX > dis[x]) { // x 之前出堆过
                continue;
            }
            for (int[] e : g[x]) {
                int y = e[0];
                int wt = e[1];
                int newDisY = disX + wt;
                if (newDisY < dis[y]) {
                    dis[y] = newDisY; // 更新 x 的邻居的最短路
                    // 懒更新堆：只插入数据，不更新堆中数据
                    // 相同节点可能有多个不同的 newDisY，除了最小的 newDisY，其余值都会触发上面的 continue
                    pq.offer(new int[]{newDisY, y});
                }
            }
        }

        return dis;
    }
}
```

- [743\. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)
- [3341\. 到达最后一个房间的最少时间 I](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/) 1721 网格图
- [3112\. 访问消失节点的最少时间](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/) 1757 理解原理
- [2642\. 设计可以求最短路径的图类](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/) 1811
- [3604\. 有向图中到达终点的最少时间](https://leetcode.cn/problems/minimum-time-to-reach-destination-in-directed-graph/) 1845
- [1514\. 概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/) 1846
- [3342\. 到达最后一个房间的最少时间 II](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/) 1862 网格图
- [1631\. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/) 1948 网格图 做法不止一种
- [1786\. 从第一个节点出发到最后一个节点的受限路径数](https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/) 2079
- [3123\. 最短路径中的边](https://leetcode.cn/problems/find-edges-in-shortest-paths/) 2093
- [1976\. 到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/) 2095
- [778\. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/) 2097 网格图 做法不止一种
- [2662\. 前往目标的最小代价](https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/) 2154
- [3377\. 使两个整数相等的数位操作](https://leetcode.cn/problems/digit-operations-to-make-two-integers-equal/) 2186
- [2045\. 到达目的地的第二短时间](https://leetcode.cn/problems/second-minimum-time-to-reach-destination/) 2202 也可以 BFS
- [3419\. 图的最大边权的最小值](https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/) 2243 做法不止一种
- [882\. 细分图中的可到达节点](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/) 2328
- [2203\. 得到要求路径的最小带权子图](https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/) 2364
- [2577\. 在网格图中访问一个格子的最少时间](https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/) 2382 网格图
- [818\. 赛车](https://leetcode.cn/problems/race-car/) 2392
- [1928\. 规定时间内到达终点的最小花费](https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/) 2413
- [787\. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/) 类似 1928 题
- [2699\. 修改图中的边权](https://leetcode.cn/problems/modify-graph-edge-weights/) 2874
- [1810\. 隐藏网格下的最小消耗路径](https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/)（会员题）
- [2093\. 前往目标城市的最小费用](https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/)（会员题）
- [2473\. 购买苹果的最低成本](https://leetcode.cn/problems/minimum-cost-to-buy-apples/)（会员题）
- [2737\. 找到最近的标记节点](https://leetcode.cn/problems/find-the-closest-marked-node/)（会员题）

**分层图最短路**：

- [LCP 35. 电动车游城市](https://leetcode.cn/problems/DFPeFJ/)
- [3599\. 划分数组得到最小 XOR](https://leetcode.cn/problems/partition-array-to-minimize-xor/) 做法不止一种
- [3594\. 所有人渡河所需的最短时间](https://leetcode.cn/problems/minimum-time-to-transport-all-individuals/) 2604
- [2714\. 找到 K 次跨越的最短路径](https://leetcode.cn/problems/find-shortest-path-with-k-hops/)（会员题）

### §3.2 全源最短路：Floyd 算法

Floyd 算法本质是三维 DP。

[带你发明 Floyd 算法：从记忆化搜索到递推](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/)

模板：

```java
class Solution {
    // 返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度
    // 如果无法从 i 到 j，则最短路长度为 Long.MAX_VALUE / 2
    // 允许负数边权
    // 如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环
    // 节点编号从 0 到 n-1
    // 时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度
    public long[][] shortestPathFloyd(int n, int[][] edges) {
        final long INF = Long.MAX_VALUE / 2; // 防止加法溢出
        long[][] f = new long[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(f[i], INF);
            f[i][i] = 0;
        }

        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int wt = e[2];
            f[x][y] = Math.min(f[x][y], wt); // 如果有重边，取边权最小值
            f[y][x] = Math.min(f[y][x], wt); // 无向图
        }

        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                if (f[i][k] == INF) { // 针对稀疏图的优化
                    continue;
                }
                for (int j = 0; j < n; j++) {
                    f[i][j] = Math.min(f[i][j], f[i][k] + f[k][j]);
                }
            }
        }
        return f;
    }
}
```

- [2642\. 设计可以求最短路径的图类](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/) 1811 动态加边
- [1334\. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) 1855
- [2976\. 转换字符串的最小成本 I](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/) 1882
- [2959\. 关闭分部的可行集合数目](https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/) 2077
- [2977\. 转换字符串的最小成本 II](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/) 2696

**Bitset 优化 Floyd**

- [1462\. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/) 1693
- [2101\. 引爆最多的炸弹](https://leetcode.cn/problems/detonate-the-maximum-bombs/)

## 四、最小生成树

涉及到 Kruskal 算法和 Prim 算法。前者一般用于稀疏图，后者一般用于稠密图。

> 注：如果要求最大生成树，把边权从大到小排序。

Kruskal 算法模板（用到了并查集，完整模板见 [数据结构题单](https://leetcode.cn/circle/discuss/mOr1u6/)）：

```java
class UnionFind {
    private final int[] fa; // 代表元
    public int cc; // 连通块个数

    UnionFind(int n) {
        // 一开始有 n 个集合 {0}, {1}, ..., {n-1}
        // 集合 i 的代表元是自己
        fa = new int[n];
        for (int i = 0; i < n; i++) {
            fa[i] = i;
        }
        cc = n;
    }

    // 返回 x 所在集合的代表元
    // 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元
    public int find(int x) {
        // 如果 fa[x] == x，则表示 x 是代表元
        if (fa[x] != x) {
            fa[x] = find(fa[x]); // fa 改成代表元
        }
        return fa[x];
    }

    // 把 from 所在集合合并到 to 所在集合中
    // 返回是否合并成功
    public boolean merge(int from, int to) {
        int x = find(from);
        int y = find(to);
        if (x == y) { // from 和 to 在同一个集合，不做合并
            return false;
        }
        fa[x] = y; // 合并集合。修改后就可以认为 from 和 to 在同一个集合了
        cc--; // 成功合并，连通块个数减一
        return true;
    }
}

class Solution {
    // 计算图的最小生成树的边权之和
    // 如果图不连通，返回 Long.MAX_VALUE
    // 节点编号从 0 到 n-1
    // 时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度
    public long mstKruskal(int n, int[][] edges) {
        Arrays.sort(edges, Comparator.comparingInt(e -> e[2]));

        UnionFind uf = new UnionFind(n);
        long sumWt = 0;
        for (int[] e : edges) {
            int x = e[0], y = e[1], wt = e[2];
            if (uf.merge(x, y)) {
                sumWt += wt;
            }
        }

        if (uf.cc > 1) { // 图不连通
            return Long.MAX_VALUE;
        }
        return sumWt;
    }
}
```

- [1584\. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/) 1858
- [3600\. 升级后最大生成树稳定性](https://leetcode.cn/problems/maximize-spanning-tree-stability-with-upgrades/) 2301 做法不止一种
- [1489\. 找到最小生成树里的关键边和伪关键边](https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/) 2572
- [1135\. 最低成本连通所有城市](https://leetcode.cn/problems/connecting-cities-with-minimum-cost/)（会员题）
- [1168\. 水资源分配优化](https://leetcode.cn/problems/optimize-water-distribution-in-a-village/)（会员题）

**思维扩展**

- [3219\. 切蛋糕的最小总开销 II](https://leetcode.cn/problems/minimum-cost-for-cutting-cake-ii/)

## 五、欧拉路径/欧拉回路

涉及到 Hierholzer 算法。

- [332\. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)
- [753\. 破解保险箱](https://leetcode.cn/problems/cracking-the-safe/) 2274
- [2097\. 合法重新排列数对](https://leetcode.cn/problems/valid-arrangement-of-pairs/) 2651

## 六、强连通分量/双连通分量

涉及到 Tarjan 算法。

- [1192\. 查找集群内的关键连接](https://leetcode.cn/problems/critical-connections-in-a-network/) 2085
- [1568\. 使陆地分离的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/) 2209
- [LCP 54. 夺回据点](https://leetcode.cn/problems/s5kipK/)
- [3383\. 施法所需最低符文数量](https://leetcode.cn/problems/minimum-runes-to-add-to-cast-spell/)（会员题）

## 七、二分图染色

- [785\. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/) 1625
- [886\. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/) 1795

关于二分图的最大匹配，见下面网络流的题目。其中标有「一对一」的题目也可以用带权二分图最大匹配做。

## 八、网络流

由于有其他做法（比如状压 DP），难度分仅供参考。

- [1947\. 最大兼容性评分和](https://leetcode.cn/problems/maximum-compatibility-score-sum/) 1704 一对一
- [3376\. 破解锁的最少时间 I](https://leetcode.cn/problems/minimum-time-to-break-locks-i/) 1793 一对一
- [2850\. 将石头分散到网格图的最少移动次数](https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/) 2001 一对多
- [1879\. 两个数组最小的异或值之和](https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/) 2145 一对一
- [1349\. 参加考试的最大学生数](https://leetcode.cn/problems/maximum-students-taking-exam/) 2386 二分图最大独立集
- [2172\. 数组的最大与和](https://leetcode.cn/problems/maximum-and-sum-of-array/) 2392 多对一
- [3276\. 选择矩阵中单元格的最大得分](https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/) 2403
- [1595\. 连通两组点的最小成本](https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/) 2538 带权二分图最小边覆盖
- [3257\. 放三个车的价值之和最大 II](https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/) 2553
- [LCP 04. 覆盖](https://leetcode.cn/problems/broken-board-dominoes/) 二分图最大匹配·模板题
- [LCP 38. 守卫城堡](https://leetcode.cn/problems/7rLGCR/) 最小割
- [1820\. 最多邀请的个数](https://leetcode.cn/problems/maximum-number-of-accepted-invitations/)（会员题）二分图最大匹配·模板题
- [2403\. 杀死所有怪物的最短时间](https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/)（会员题）同 3376 题
- [3385\. 破解锁的最少时间 II](https://leetcode.cn/problems/minimum-time-to-break-locks-ii/)（会员题）同 3376 题
- [1066\. 校园自行车分配 II](https://leetcode.cn/problems/campus-bikes-ii/)（会员题）一对一，但不是完美匹配
- [2123\. 使矩阵中的 1 互不相邻的最小操作数](https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/)（会员题）二分图最大独立集

**模拟费用流**

- [2463\. 最小移动总距离](https://leetcode.cn/problems/minimum-total-distance-traveled/) 做到

## 九、其他

- [1042\. 不邻接植花](https://leetcode.cn/problems/flower-planting-with-no-adjacent/) 1712
- [1761\. 一个图中连通三元组的最小度数](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/) 2005
- [2508\. 添加边使所有节点度数都为偶数](https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/) 2060
- [1579\. 保证图可完全遍历](https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/) 2132
- [2065\. 最大化一张图中的路径价值](https://leetcode.cn/problems/maximum-path-quality-of-a-graph/) 2178
- [1697\. 检查边长度限制的路径是否存在](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/) 2300
- [2242\. 节点序列的最大得分](https://leetcode.cn/problems/maximum-score-of-a-node-sequence/) 2304
- [2493\. 将节点分成尽可能多的组](https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/) 2415 **推荐**
- [1782\. 统计点对的数目](https://leetcode.cn/problems/count-pairs-of-nodes/) 2457
- [3435\. 最短公共超序列的字母出现频率](https://leetcode.cn/problems/frequencies-of-shortest-supersequences/) 3028
- [466\. 统计重复个数](https://leetcode.cn/problems/count-the-repetitions/) 做到
- [LCP 46. 志愿者调配](https://leetcode.cn/problems/05ZEDJ/)
- [LCP 16. 游乐园的游览计划](https://leetcode.cn/problems/you-le-yuan-de-you-lan-ji-hua/)
- [277\. 搜寻名人](https://leetcode.cn/problems/find-the-celebrity/)（会员题）
- [1724\. 检查边长度限制的路径是否存在 II](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/)（会员题）
- [2077\. 殊途同归](https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/)（会员题）

## 十、树上算法

见 [链表、树、回溯](https://leetcode.cn/circle/discuss/K0n2gO/) 题单的第三章节。

## 关联题单

- 关于**网格图**的 DFS 和 BFS，见 [网格图题单](https://leetcode.cn/circle/discuss/YiXPXW/)。
